""" Boilerplate Info
ProfileReader.PY - Import profile data from CSV [R0], scrub it, export standardized format.
* CSV must be generated by MVDC Excel Addin (as fetched from MVDC database).
* Backbone exists to examine multiple datatypes, but as of R0 is hardcoded to look at BW, CW, Moi, and ActFB

Created 08/25/17/PP - [R0]

Edited  MM/DD/YY/NN - [R1]

"""

# Libraries
import csv
import numpy
from math import isnan

# Globals - to the chagrin of all professionals
CWBinLimits = [15,30]
BWBinLimits = [15,30]
MoiBinLimits = [3,17]
ScanCountLimits = [70,200]

def CSV2Arrays(csvfile,ReturnDict = False):
    """
    Opens a CSV file,r eads it, and returns an array or dictionaries. Dict should be preferred.
    :param csvfile: string with address of csv file
    :param ReturnDict: Boolean - True if you want a dict, False if you want an array
    :return: Dict or Array
    """
    ArrayOfArrays = []
    DictOfArrays = {}
    RawRead = []
    with open('TestData.csv','rb') as CSVFile:
        CSVReader = csv.reader(CSVFile,delimiter=',')
        for line in CSVReader:
            RawRead.append(line)
    # File read, close it up

    # Mark the header and replace it with zeros just to make the next loop cleaner
    HeaderArray = RawRead[0]

    RawRead[0] = numpy.zeros((len(RawRead[0])),dtype=numpy.int8)

    # Store in temporary list to write to dictionary - reduces memory load
    Temp = [HeaderArray]

    for line in range(len(RawRead))[1:]:

        if RawRead[line][0]:
            Temp.append(RawRead[line])
        elif RawRead[line+1][0]:
            ArrayOfArrays.append(Temp)
            Temp = [HeaderArray]
        if line == len(RawRead[1:]):
            ArrayOfArrays.append(Temp)
        #else:
            #Temp = [HeaderArray]

    #print ArrayOfArrays
    if not ReturnDict:
        return ArrayOfArrays
    else:
        for dataset in ArrayOfArrays:
            DictOfArrays[dataset[1][0]] = dataset
        return DictOfArrays

def ScrubArrays(HeaderArray,ReelArrays,*Limits, **OtherLimits):
    """
    :param HeaderArray:
    :param ReelArrays:
    :param Limits:
    :param OtherLimits:
    :return:
    """
    TimeCol = HeaderArray.index("Turnup Time")
    try:
      ReelNumCol = HeaderArray.index("PPR Reel Number")
    except ValueError:
        try:
            ReelNumCol = HeaderArray.index("Gauge Reel Number")
            print "PPR Reel Numbers are preferred but not found - using Gauge Reel Number"
        except ValueError:
            print "Could not find Reel Number - proceeding without."

    # TimeCol = HeaderArray.index("PPR Reel Number")
    ScanCol = HeaderArray.index("Number of Scans")
    StartCol = HeaderArray.index("Pos_1")
    EndCol = HeaderArray.index("Pos_1120")

def ConvertPossibleToFloat(item):
    """
    If this breaks, replace it with pandas
    :param item: string
    :return: float version of that string
    """
    try:
        item = float(item)
    except ValueError:
        pass
    return item

def ScrubStandardDictionary(ScrubMe,
                            LowScanLimit = 0, HighScanLimit = 0,
                            LowWtLimit = 0, HighWtLimit = 0,
                            LowMoiLimit = 0, HighMoiLimit = 0):
    """
    :param ScrubMe: Dict to be scrubbed
    :param LowScanLimit: # of scans that's too few
    :param HighScanLimit: # of scans that's too many
    :param LowWtLimit: lbs of weight to ignore reel
    :param HighWtLimit: lbs of weight to ignore reel
    :param LowMoiLimit: % Moi that ignores reel
    :param HighMoiLimit: % Moi that ignors reel
    :return: Dictionary with reels removed for having bad data
    """

    KeyList = ScrubMe.keys()
    BadReelList = []

    # First lets get rid of the name lines
    for k,v in ScrubMe.iteritems():
        v.pop(1)

    # Now let's turn anything we can into a number. Stupid quotes.
    for k,v in ScrubMe.iteritems():
        for reel_index in range(len(v)):
            for item_index in range(len(v[reel_index])):
                v[reel_index][item_index] = ConvertPossibleToFloat(v[reel_index][item_index])



    # Next lets ID any reels with bad scan counts
    if LowScanLimit or HighScanLimit:
        ScanCol = ScrubMe[KeyList[0]][0].index('Number of Scans')
        for reel in ScrubMe[KeyList[0]][1:]:
            if int(reel[ScanCol]) < LowScanLimit or int(reel[ScanCol]) > HighScanLimit:
                BadReelList.append(reel[0])

    # And any reels with bad moisture averages
    if LowMoiLimit or HighMoiLimit:
        MoistureKey = 'RL.MST (10)'
        try:
            ScrubMe[MoistureKey]
        except KeyError:
            MoistureKey = input("%s doesn't seem to exist - what's your moisture data called?\n" % MoistureKey)

        MoiCol = ScrubMe[MoistureKey][0].index('Reel Average')
        for reel in ScrubMe[MoistureKey][1:]:
            if float(reel[MoiCol]) < LowMoiLimit or float(reel[MoiCol]) > HighMoiLimit:
                print reel[MoiCol]
                BadReelList.append(reel[0])

    # Aaaand reels with bad weight averages...
    if LowWtLimit or HighWtLimit:
        WeightKey = 'RL.BSWT (7)'
        try:
            ScrubMe[WeightKey]
        except KeyError:
            WeightKey = input("%s doesn't seem to exist - what's your weight data called?\n" % WeightKey)

        BWCol = ScrubMe[WeightKey][0].index('Reel Average')
        for reel in ScrubMe[WeightKey][1:]:
            if float(reel[BWCol]) < LowWtLimit or float(reel[BWCol]) > HighWtLimit:
                print reel[BWCol]


    # Now with that list, let's remove the offending reels from every dataset.
    if len(BadReelList) > 0:
        for k, v in ScrubMe.iteritems():
            for reel_index in range(len(v)-1):
                if v[reel_index][0] in BadReelList:
                    v.pop(reel_index)

                    # Alternative is to pop from the back
    return ScrubMe

def JustTheData(DictionaryIn):
    # Take in dictionary of datasets, spit out dictionary with only timestamp and pos1-pos1120

    NewDict = {}

    for k,v in DictionaryIn.iteritems():
        TempArrayArray = []
        for reel_index in range(len(v)-1):
            if reel_index == 0:
                # DateIndex = v[reel_index].index("Turnup Time")
                PosFirstIndex = v[reel_index].index("Pos_1")
                PosLastIndex = v[reel_index].index("Pos_1120")
            else:
                GoodReelData = [x for x in v[reel_index][PosFirstIndex:PosLastIndex] if not isnan(x)]
                # TempArrayArray.append(v[reel_index][PosFirstIndex:PosLastIndex])
                TempArrayArray.append(GoodReelData)

            # for item_index in range(len(v[reel_index])-1):

                # if item_index <> DateIndex and (item_index < PosFirstIndex or item_index > PosLastIndex):
                #     print v[reel_index].pop(item_index)

        NewDict[k] = TempArrayArray

    return NewDict


if __name__ == "__main__":
    print "Hello World"


    DatasetDictionary = CSV2Arrays("TestData.csv",True)
    DatasetDictionary = ScrubStandardDictionary(DatasetDictionary,LowMoiLimit = MoiBinLimits[0], HighMoiLimit = MoiBinLimits[1],
                            LowWtLimit = BWBinLimits[0], HighWtLimit=BWBinLimits[1],
                            LowScanLimit=ScanCountLimits[0], HighScanLimit=ScanCountLimits[1])

    DataOnlyDictionary = JustTheData(DatasetDictionary)
