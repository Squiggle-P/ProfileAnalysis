""" Boilerplate Info
ProfileReader.PY - Import profile data from CSV [R0], scrub it, export standardized format.
* CSV must be generated by MVDC Excel Addin (as fetched from MVDC database).
* Backbone exists to examine multiple datatypes, but as of R0 is hardcoded to look at BW, CW, Moi, and ActFB

Created 08/25/17/PP - [R0]:


Edited  MM/DD/YY/NN - [R1]:

"""

# Libraries
import csv
import numpy

# Globals - to the chagrin of all professionals
CWBinLimits = [15,30]
BWBinLimits = [15,30]
MoiBinLimits = [3,17]
ScanCountLimits = [70,200]

def CSV2Arrays(csvfile,ReturnDict = False):
    """ Opens a CSV file, reads it, returns an array of dictionaries with header keys"""
    ArrayOfArrays = []
    DictOfArrays = {}
    RawRead = []
    with open('TestData.csv','rb') as CSVFile:
        CSVReader = csv.reader(CSVFile,delimiter=',')
        for line in CSVReader:
            RawRead.append(line)
    # File read, close it up

    HeaderArray = RawRead[0]

    RawRead[0] = numpy.zeros((len(RawRead[0])),dtype=numpy.int8)
    #print RawRead[0]
    #print HeaderArray

    Temp = [HeaderArray]

    for line in range(len(RawRead))[1:]:
#        print RawRead[line]
#        print RawRead[line][0]
        if RawRead[line][0]:
            Temp.append(RawRead[line])
        elif RawRead[line+1][0]:
            ArrayOfArrays.append(Temp)
            Temp = [HeaderArray]
        if line == len(RawRead[1:]):
            ArrayOfArrays.append(Temp)
        #else:
            #Temp = [HeaderArray]

    #print ArrayOfArrays
    if not ReturnDict:
        return ArrayOfArrays
    else:
        for dataset in ArrayOfArrays:
            DictOfArrays[dataset[1][0]] = dataset
        return DictOfArrays

def ScrubArrays(HeaderArray,ReelArrays,*Limits, **OtherLimits):


  print "Hello World"
  TimeCol = HeaderArray.index("Turnup Time")
  try:
    ReelNumCol = HeaderArray.index("PPR Reel Number")
  except ValueError:
      try:
          ReelNumCol = HeaderArray.index("Gauge Reel Number")
          print "PPR Reel Numbers are preferred but not found - using Gauge Reel Number"
      except ValueError:
          print "Could not find Reel Number - proceeding without."

  # TimeCol = HeaderArray.index("PPR Reel Number")
  ScanCol = HeaderArray.index("Number of Scans")
  StartCol = HeaderArray.index("Pos_1")
  EndCol = HeaderArray.index("Pos_1120")

def ConvertPossibleToFloat(item):
    try:
        item = float(item)
    except ValueError:
        pass
    return item

def ScrubStandardDictionary(ScrubMe,
                            LowScanLimit = 0, HighScanLimit = 0,
                            LowWtLimit = 0, HighWtLimit = 0,
                            LowMoiLimit = 0, HighMoiLimit = 0):

    KeyList = ScrubMe.keys()
    BadReelList = []

    # First lets get rid of the name lines
    for k,v in ScrubMe.iteritems():
        v.pop(1)

    # Now let's turn anything we can into a number. Stupid quotes.
    for k,v in ScrubMe.iteritems():
        for reel_index in range(len(v)):
            for item_index in range(len(v[reel_index])):
                v[reel_index][item_index] = ConvertPossibleToFloat(v[reel_index][item_index])



    # Next lets ID any reels with bad scan counts
    if LowScanLimit or HighScanLimit:
        ScanCol = ScrubMe[KeyList[0]][0].index('Number of Scans')
        for reel in ScrubMe[KeyList[0]][1:]:
            if int(reel[ScanCol]) < LowScanLimit or int(reel[ScanCol]) > HighScanLimit:
                BadReelList.append(reel[0])

    # And any reels with bad moisture averages
    if LowMoiLimit or HighMoiLimit:
        MoistureKey = 'RL.MST (10)'
        try:
            ScrubMe[MoistureKey]
        except KeyError:
            MoistureKey = input("%s doesn't seem to exist - what's your moisture data called?\n" % MoistureKey)

        MoiCol = ScrubMe[MoistureKey][0].index('Reel Average')
        for reel in ScrubMe[MoistureKey][1:]:
            if float(reel[MoiCol]) < LowMoiLimit or float(reel[MoiCol]) > HighMoiLimit:
                print reel[MoiCol]
                BadReelList.append(reel[0])

    # Aaaand reels with bad weight averages...
    if LowWtLimit or HighWtLimit:
        WeightKey = 'RL.BSWT (7)'
        try:
            ScrubMe[WeightKey]
        except KeyError:
            WeightKey = input("%s doesn't seem to exist - what's your weight data called?\n" % WeightKey)

        BWCol = ScrubMe[WeightKey][0].index('Reel Average')
        for reel in ScrubMe[WeightKey][1:]:
            if float(reel[BWCol]) < LowWtLimit or float(reel[BWCol]) > HighWtLimit:
                print reel[BWCol]


    # Now with that list, let's remove the offending reels from every dataset.
    if len(BadReelList) > 0:
        for k, v in ScrubMe.iteritems():
            for reel_index in range(len(v)-1):
                if v[reel_index][0] in BadReelList:
                    v.pop(reel_index)

    return ScrubMe


if __name__ == "__main__":
    print "Hello World"
    UnknownArrays = []
    # Import CSVs and process into arrays - hardcoded.
    # for dataset in CSV2Arrays("TestData.csv"):
    #     #print dataset[1][0]
    #     if dataset[1][0] == 'RL.BSWT (7)':
    #         BWArray = dataset
    #     elif dataset[1][0] == 'RL.MST (10)':
    #         MoiArray = dataset
    #     elif dataset[1][0] == 'RL.CNDWT (13)':
    #         CWArray = dataset
    #     elif dataset[1][0] == 'CTRL.HBDILFB (97)':
    #         ActArray = dataset
    #     else:
    #         UnknownArrays.append(dataset)
    #         print "Unknown Array %s found and logged as UnknownArrays[%s]" % (dataset[1][0], len(UnknownArrays)-1)

    DatasetDictionary = CSV2Arrays("TestData.csv",True)
    DatasetDictionary = ScrubStandardDictionary(DatasetDictionary,LowMoiLimit = MoiBinLimits[0], HighMoiLimit = MoiBinLimits[1],
                            LowWtLimit = BWBinLimits[0], HighWtLimit=BWBinLimits[1],
                            LowScanLimit=ScanCountLimits[0], HighScanLimit=ScanCountLimits[1])

